which.max(step_summary$adjr2)
)
)
model_summary
kable(model_summary, "html", caption = "Best Model Size Based on Different Criteria") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
model_summary
x = model.matrix(Salary ~., Hitters)[,-1]
x
y = Hitters$Salary
grid = 10^sep(8, -2, length = 100)
grid = 10^seq(8, -2, length = 100)
grid
?glmnet
lasso.mod = glmnet(x[inTrain,],
y[inTrain],
alpha = 1,
lambda = grid,
standardize = T)
inTrain = createDataPartition(Hitters$Salary, p = 0.6)[[1]]
x = model.matrix(Salary ~., Hitters)[,-1]
y = Hitters$Salary
grid = 10^seq(8, -2, length = 100)
lasso.mod = glmnet(x[inTrain,],
y[inTrain],
alpha = 1,
lambda = grid,
standardize = T)
plot(lasso.mode, xvar = "lambda", label = T)
plot(lasso.mod, xvar = "lambda", label = T)
cv.out = cv.glmnet(x[inTrain,],
y[inTrain],
alpha = 1)
plot(cv.out)
cv.out$lambda.1se
cv.out$glmnet.fit$beta
cv.out$glmnet.fit$beta[, which(cv.out$lambda == cv.out$lambda.1se)]
test.pred = predict(cv.out, x[-inTrain],)
test.pred = predict(cv.out, x[-inTrain,],)
test.pred
test.pred = predict(cv.out, x[-inTrain,],)[,1]
test.pred
mse.lasso = mean((test.pred - y[-inTrain])^2)
mse.lasso
knitr::opts_chunk$set(echo = TRUE)
s = function(x){x^3 * sin((x + 3.4)/2)}
s(1)
seq(0,3 length.out = 1000)
seq(0,3, length.out = 1000)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
x.plot = seq(0,3, length.out = 1000)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
x.plot = seq(0,3, length.out = 200)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
s = function(x){x^3 * sin((x + 3.4)/2)}
x.plot = seq(0,3, length.out = 20)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
s = function(x){x^3 * sin((x + 3.4)/2)}
x.plot = seq(0,3, length.out = 1000)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
s = function(x){x^3 * sin((x + 3.4)/2)}
x.plot = seq(0,3, length.out = 1000)
y.plot = s(x.plot)
plot(x.plot, y.plot, type = "l")
set.seed(5003)
n = 50000
x = runif(n, min = 0, max = 3)
sx = s(x)
set.seed(5003)
n = 50000
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
integrate(s, 0, 3)
set.seed(5003)
n = 200
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
n = 100
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
n = 10
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
n = 10000
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
n = 100000
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
n = 1000000
x = runif(n, min = 0, max = 3)
sx = s(x)
# integral and then multiply by b - a
# int^b _a
(3-0) * mean(sx)
set.seed(5003)
set.seed(5003)
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
set.seed(5003)
stock.sim = function(ndays = 90, S0 = 100,
mu = 0.05, sigma = 0.5){
N = rnorm(ndays)
S = S0
dt = 1/365
Ssim = S
for (i in 1:ndays){
dS = S * (mu * dT + sigma * sqrt(dT) * N[i])
S = S + dS
Ssim = c(Ssim, S) # Store todays date
}
Ssim
}
# stock.sim = function with inputs ....
# N = ndays number of standard normal distribution obs.
# S = S0 (0th day stock price)
# dt = 1/365 (one time increment)
# Ssim = S (store current price in vector)
# For each day in ndays:
# ds = S * (mu * dT + sigma * sqrt(dT) * N[i]) (brownian model)
# S = S + dS (update current price)
# Ssim = store todays date in historical vector
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
set.seed(5003)
stock.sim = function(ndays = 90, S0 = 100,
mu = 0.05, sigma = 0.5){
N = rnorm(ndays)
S = S0
dt = 1/365
Ssim = S
for (i in 1:ndays){
dS = S * (mu * dt + sigma * sqrt(dT) * N[i])
S = S + dS
Ssim = c(Ssim, S) # Store todays date
}
Ssim
}
# stock.sim = function with inputs ....
# N = ndays number of standard normal distribution obs.
# S = S0 (0th day stock price)
# dt = 1/365 (one time increment)
# Ssim = S (store current price in vector)
# For each day in ndays:
# ds = S * (mu * dT + sigma * sqrt(dT) * N[i]) (brownian model)
# S = S + dS (update current price)
# Ssim = store todays date in historical vector
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
set.seed(5003)
stock.sim = function(ndays = 90, S0 = 100,
mu = 0.05, sigma = 0.5){
N = rnorm(ndays)
S = S0
dt = 1/365
Ssim = S
for (i in 1:ndays){
dS = S * (mu * dt + sigma * sqrt(dt) * N[i])
S = S + dS
Ssim = c(Ssim, S) # Store todays date
}
Ssim
}
# stock.sim = function with inputs ....
# N = ndays number of standard normal distribution obs.
# S = S0 (0th day stock price)
# dt = 1/365 (one time increment)
# Ssim = S (store current price in vector)
# For each day in ndays:
# ds = S * (mu * dT + sigma * sqrt(dT) * N[i]) (brownian model)
# S = S + dS (update current price)
# Ssim = store todays date in historical vector
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
simulated.prices
simulated.prices = unlist(simulated.prices)
simulated.prices
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
simulated.prices[[1]]
simulated.prices[[1]] |> length()
simulated.prices = unlist(simulated.prices)
price.dat = data.frame(days = rep(0:90, 5),
price.dat
sigma = c(0.1,0.25,0.5,0.75,1)
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
simulated.prices = unlist(simulated.prices)
price.dat = data.frame(days = rep(0:90, 5),
prices = simulated.prices,
Sigma = factor(rep(sigma, each = 91))
sigma = c(0.1,0.25,0.5,0.75,1)
simulated.prices = list()
for (sig in 1:length(sigma)){
simulated.prices[[sig]] = stock.sim(sigma = sigma[sig])
}
simulated.prices = unlist(simulated.prices)
price.dat = data.frame(days = rep(0:90, 5),
prices = simulated.prices,
Sigma = factor(rep(sigma, each = 91)))
price.dat
ggplot(price.dat) + geom_line(aes(x = days,
y = prices,
group = Sigma,
colour = Sigma)) +
theme_minimal()
library(tidyverse)
ggplot(price.dat) + geom_line(aes(x = days,
y = prices,
group = Sigma,
colour = Sigma)) +
theme_minimal()
stock.prices
simulated.prices
knockout.payoff = function(stock.prices,
strike.price,
knockout){
if(any(stock.prices > strike.price)){
return(0)
}else{
return(max(tail(stock.prices, 1) - strike.price, 0))
}
}
knockout.payoff = function(stock.prices,
strike.price,
knockout){
if(any(stock.prices > strike.price)){
return(0)
}else{
return(max(tail(stock.prices, 1) - strike.price, 0))
}
}
vanilla.payoff = function(stock.prices,
strike.price){
return(max(tail(stock.prices, 1) - strike.price, 0))
}
simulated.prices = matrix(NA, nrow = 91, ncol = n.iterations)
knockout.payoff = function(stock.prices,
strike.price,
knockout){
if(any(stock.prices > strike.price)){
return(0)
}else{
return(max(tail(stock.prices, 1) - strike.price, 0))
}
}
vanilla.payoff = function(stock.prices,
strike.price){
return(max(tail(stock.prices, 1) - strike.price, 0))
}
set.seed(5003)
# Initialising variables
n.iterations <- 5000
S0 <- 100
mu <- 0.05
sigma <- 0.5
ndays <- 90
simulated.prices = matrix(NA, nrow = 91, ncol = n.iterations)
knockout.payoff = function(stock.prices,
strike.price,
knockout){
if(any(stock.prices > strike.price)){
return(0)
}else{
return(max(tail(stock.prices, 1) - strike.price, 0))
}
}
vanilla.payoff = function(stock.prices,
strike.price){
return(max(tail(stock.prices, 1) - strike.price, 0))
}
set.seed(5003)
# Initialising variables
n.iterations <- 5000
S0 <- 100
mu <- 0.05
sigma <- 0.5
ndays <- 90
simulated.prices = matrix(NA, nrow = 91, ncol = n.iterations)
for(i in 1:n.iterations){
simulated.prices[,i] = stock.sim(ndays = ndays,
S0 = S0,
mu = mu,
sigma = sigma)
}
exotic.payoffs = c()
vaniall.payoffs = c()
vanilla.payoffs = c()
exotic.payoffs = c()
vanilla.payoffs = c()
for (i in 1:n.iterations){
exotic.payoffs[i] = knockout.payoff(simulated.prices[,i],
105,
130)
vanilla.payoffs[i] = vanilla.payoff(simulated.prices[,i],
105)
}
?boxplot
boxplot(exotic.payoffs, vanilla.payoffs, names = c("exotic", "vanilla"))
install.packages("pak")
pak::pak("rajan-shankar/roams")
library(roams)
set.seed(5003)
theta = 0.7 # P(Head)
N = 200
# simulate some coin flips
coin.flips <- rbinom(n = N, size = 1, prob = theta)
coin.flips
likelihood = function(theta,  x){
prod(dbinom(x, size = 1, prob = theta))
}
niters = 1000 # number of steps (iterations)
curr.theta = 0.5 # intial
theta.chain = numeric(niters) # store our steps.
# theta is a probability, it is bounded by 0 and 1.
for (i in 0:(niters - 1)){
proposal.theta = curr.theta +
rnorm(1, mean = 0, sd = 0.05)
if (proposa.theta < 0 || proposal.theta >1){
theta.chain[i + 1] = curr.theta
next
}
curr.likeli = likelihood(curr.theta, coin.flips)
proposal.likeli = likelihood(proposal.theta, coin.flips)
alpha = min(proposal.likeli/curr.likeli, 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
niters = 1000 # number of steps (iterations)
curr.theta = 0.5 # intial
theta.chain = numeric(niters) # store our steps.
# theta is a probability, it is bounded by 0 and 1.
for (i in 0:(niters - 1)){
proposal.theta = curr.theta +
rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta < 0 || proposal.theta >1){
theta.chain[i + 1] = curr.theta
next
}
curr.likeli = likelihood(curr.theta, coin.flips)
proposal.likeli = likelihood(proposal.theta, coin.flips)
alpha = min(proposal.likeli/curr.likeli, 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
mean(theta.chain)
hist(theta.chain)
0.000001 * 0.000001
0.000001 * 0.000000001
0.000001 * 0.0000000000001
0.000001 * 0.0000000000000000000001
0.000001 * 0.0000000000000000000001 * 0.0000001
p <- 0.4
mn <- c(-1, 2)
std <- c(0.2, 1.5)
f <- function(x, mu = mn, sd = std)  p * dnorm(x, mu[1], sd[1]) + (1 - p) * dnorm(x, mu[2], sd[2])
curve(f(x), col = "red", from = -4, to = 8, n = 300, las = 1)
q = function(x, sigma){
rnorm(1, mean = x, sd = sigma)
}
mc.algorithm = function(x_0, n, sigma){
x = numeric(n)
x[1] = x_0
for (i in 1:(n-1)){
prop.x = q(x[i], sigma = sigma)
prop.likeli = f(prop.x)
curr.likeli = f(x[1])
alpha = min(prop.likeli/curr.likeli , 1)
if (runif(1) < alpha){
x[i + 1] = prop.x
}else{
x[i + 1] = x[i]
}
}
}
set.seed(5003)
x0_vals = c(-1,1,5)
sigma_vals = c(0.01, 0.5,20)
x = seq(-4, 8, length.out = 1000)
parameters = expand.grid(x0_vals, sigma_vals)
parameters
for (x0 in x0_vals) {
for (s in sigma_vals) {
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
hist(output, probability = TRUE,
main = paste("x_0 =", x0, "; σ =", s),
breaks = seq(-5, 10, by = 0.2))
lines(x, f(x), col = "red")
}
}
x
set.seed(5003)
x0_vals = c(-1,1,5)
sigma_vals = c(0.01, 0.5,20)
x = seq(-4, 8, length.out = 1000)
parameters = expand.grid(x0_vals, sigma_vals)
for (x0 in x0_vals) {
for (s in sigma_vals) {
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
hist(output, probability = TRUE,
main = paste("x_0 =", x0, "; σ =", s),
breaks = seq(-5, 10, by = 0.2))
lines(x, f(x), col = "red")
}
}
f(x)
x
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
hist(output, probability = TRUE,
main = paste("x_0 =", x0, "; σ =", s),
breaks = seq(-5, 10, by = 0.2))
output
mc.algorithm = function(x_0, n, sigma){
x = numeric(n)
x[1] = x_0
for (i in 1:(n-1)){
prop.x = q(x[i], sigma = sigma)
prop.likeli = f(prop.x)
curr.likeli = f(x[1])
alpha = min(prop.likeli/curr.likeli , 1)
if (runif(1) < alpha){
x[i + 1] = prop.x
}else{
x[i + 1] = x[i]
}
}
x
}
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
output
for (x0 in x0_vals) {
for (s in sigma_vals) {
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
hist(output, probability = TRUE,
main = paste("x_0 =", x0, "; σ =", s),
breaks = seq(-5, 10, by = 0.2))
lines(x, f(x), col = "red")
}
}
for (x0 in x0_vals) {
for (s in sigma_vals) {
output <- mc.algorithm(x_0 = x0, n = 50000, sigma = s)
hist(output, probability = TRUE,
main = paste("x_0 =", x0, "; σ =", s),
breaks = seq(-5, 10, by = 0.2))
lines(x, f(x), col = "red")
}
}
setwd("~/Library/CloudStorage/OneDrive-Personal/PhD/Exclusion Automatic Threshold Selection/Automatic Threshold Selection")
n = 100
p = 10
toes2 = 0.2^abs(row(matrix(1:p, p, p)) - col(matrix(1:p, p, p)))
x = mvtnorm::rmvt(n = n, sigma = toes2, df = 3)
hist(x)
boxplot(x)
# Generate random data from multivariate gaussian with Toeplitz covariance matrix
toeshd = 0.5^abs(row(matrix(1:p, p, p)) - col(matrix(1:p, p, p)))
x = mvtnorm::rmvnorm(n  = n, sigma = toeshd)
boxplot(x)
