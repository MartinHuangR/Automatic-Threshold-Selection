csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
### ATS Function ###
Rcpp::cppFunction('
int getR(const NumericVector& d) {
int p = d.size();
NumericVector lq(p, 0.0);
NumericVector sigma2(p);
for (int q = 0; q < p; q++) {
NumericVector d1 = head(d, q + 1);
NumericVector d2 = tail(d, p - (q + 1));
double mu1 = mean(d1);
double mu2 = mean(d2);
sigma2[q] = (sum(pow(d1 - mu1, 2)) + sum(pow(d2 - mu2, 2))) / (p - 2);
lq[q] = sum(dnorm(d1, mu1, sqrt(sigma2[q]), true)) +
sum(dnorm(d2, mu2, sqrt(sigma2[q]), true));
}
return which_max(lq) + 1;
}
')
Rcpp::cppFunction('
int betaElbow(NumericVector d, double eps=1e-6){
int p = d.size();
if(p < 2) stop("d must have length >= 2");
// Precompute clipped logs
NumericVector lx(p), l1x(p);
for(int i=0;i<p;i++){
double xi = d[i];
double xc = std::min(1.0 - eps, std::max(eps, xi));
lx[i] = std::log(xc);
l1x[i] = std::log(1.0 - xc);
}
// Cumulated sums for fast mean/var
NumericVector csum(p+1), csum2(p+1);
csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
### ATS Function ###
Rcpp::cppFunction('
int getR(const NumericVector& d) {
int p = d.size();
NumericVector lq(p, 0.0);
NumericVector sigma2(p);
for (int q = 0; q < p; q++) {
NumericVector d1 = head(d, q + 1);
NumericVector d2 = tail(d, p - (q + 1));
double mu1 = mean(d1);
double mu2 = mean(d2);
sigma2[q] = (sum(pow(d1 - mu1, 2)) + sum(pow(d2 - mu2, 2))) / (p - 2);
lq[q] = sum(dnorm(d1, mu1, sqrt(sigma2[q]), true)) +
sum(dnorm(d2, mu2, sqrt(sigma2[q]), true));
}
return which_max(lq) + 1;
}
')
Rcpp::cppFunction('
int betaElbow(NumericVector d, double eps=1e-6){
int p = d.size();
if(p < 2) stop("d must have length >= 2");
// Precompute clipped logs
NumericVector lx(p), l1x(p);
for(int i=0;i<p;i++){
double xi = d[i];
double xc = std::min(1.0 - eps, std::max(eps, xi));
lx[i] = std::log(xc);
l1x[i] = std::log(1.0 - xc);
}
// Cumulated sums for fast mean/var
NumericVector csum(p+1), csum2(p+1);
csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
### ATS Function ###
Rcpp::cppFunction('
int getR(const NumericVector& d) {
int p = d.size();
NumericVector lq(p, 0.0);
NumericVector sigma2(p);
for (int q = 0; q < p; q++) {
NumericVector d1 = head(d, q + 1);
NumericVector d2 = tail(d, p - (q + 1));
double mu1 = mean(d1);
double mu2 = mean(d2);
sigma2[q] = (sum(pow(d1 - mu1, 2)) + sum(pow(d2 - mu2, 2))) / (p - 2);
lq[q] = sum(dnorm(d1, mu1, sqrt(sigma2[q]), true)) +
sum(dnorm(d2, mu2, sqrt(sigma2[q]), true));
}
return which_max(lq) + 1;
}
')
Rcpp::cppFunction('
int betaElbow(NumericVector d, double eps=1e-6){
int p = d.size();
if(p < 2) stop("d must have length >= 2");
// Precompute clipped logs
NumericVector lx(p), l1x(p);
for(int i=0;i<p;i++){
double xi = d[i];
double xc = std::min(1.0 - eps, std::max(eps, xi));
lx[i] = std::log(xc);
l1x[i] = std::log(1.0 - xc);
}
// Cumulated sums for fast mean/var
NumericVector csum(p+1), csum2(p+1);
csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
### ATS Function ###
Rcpp::cppFunction('
int getR(const NumericVector& d) {
int p = d.size();
NumericVector lq(p, 0.0);
NumericVector sigma2(p);
for (int q = 0; q < p; q++) {
NumericVector d1 = head(d, q + 1);
NumericVector d2 = tail(d, p - (q + 1));
double mu1 = mean(d1);
double mu2 = mean(d2);
sigma2[q] = (sum(pow(d1 - mu1, 2)) + sum(pow(d2 - mu2, 2))) / (p - 2);
lq[q] = sum(dnorm(d1, mu1, sqrt(sigma2[q]), true)) +
sum(dnorm(d2, mu2, sqrt(sigma2[q]), true));
}
return which_max(lq) + 1;
}
')
Rcpp::cppFunction('
int betaElbow(NumericVector d, double eps=1e-6){
int p = d.size();
if(p < 2) stop("d must have length >= 2");
// Precompute clipped logs
NumericVector lx(p), l1x(p);
for(int i=0;i<p;i++){
double xi = d[i];
double xc = std::min(1.0 - eps, std::max(eps, xi));
lx[i] = std::log(xc);
l1x[i] = std::log(1.0 - xc);
}
// Cumulated sums for fast mean/var
NumericVector csum(p+1), csum2(p+1);
csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
### ATS Function ###
Rcpp::cppFunction('
int getR(const NumericVector& d) {
int p = d.size();
NumericVector lq(p, 0.0);
NumericVector sigma2(p);
for (int q = 0; q < p; q++) {
NumericVector d1 = head(d, q + 1);
NumericVector d2 = tail(d, p - (q + 1));
double mu1 = mean(d1);
double mu2 = mean(d2);
sigma2[q] = (sum(pow(d1 - mu1, 2)) + sum(pow(d2 - mu2, 2))) / (p - 2);
lq[q] = sum(dnorm(d1, mu1, sqrt(sigma2[q]), true)) +
sum(dnorm(d2, mu2, sqrt(sigma2[q]), true));
}
return which_max(lq) + 1;
}
')
Rcpp::cppFunction('
int betaElbow(NumericVector d, double eps=1e-6){
int p = d.size();
if(p < 2) stop("d must have length >= 2");
// Precompute clipped logs
NumericVector lx(p), l1x(p);
for(int i=0;i<p;i++){
double xi = d[i];
double xc = std::min(1.0 - eps, std::max(eps, xi));
lx[i] = std::log(xc);
l1x[i] = std::log(1.0 - xc);
}
// Cumulated sums for fast mean/var
NumericVector csum(p+1), csum2(p+1);
csum[0]=0.0; csum2[0]=0.0;
for(int i=0;i<p;i++){
csum[i+1]=csum[i]+d[i];
csum2[i+1]=csum2[i]+d[i]*d[i];
}
auto seg_mom = [&](int a, int b){
int n = b - a;
double s  = csum[b]  - csum[a];
double s2 = csum2[b] - csum2[a];
double mu = s / n;
double var = (s2 - s*s/n) / std::max(1, n-1);
if(!R_finite(var) || var <= 0) var = 1e-12; // stabilize
return std::pair<double,double>(mu,var);
};
auto seg_loglik = [&](int a, int b){
int n = b - a;
auto mv = seg_mom(a,b);
double mu = std::min(1.0 - 1e-12, std::max(1e-12, mv.first));
double var = std::min(mu*(1.0-mu) - 1e-12, std::max(1e-12, mv.second));
double nu = (mu*(1.0-mu))/var - 1.0;           // ν = μ(1-μ)/var - 1
if(!R_finite(nu) || nu <= 0) nu = 1e-6;
double alpha = std::max(1e-6, mu*nu);
double beta  = std::max(1e-6, (1.0-mu)*nu);
double lb = R::lbeta(alpha, beta);
double s=0.0;
for(int i=a;i<b;i++){
s += (alpha-1.0)*lx[i] + (beta-1.0)*l1x[i] - lb; // log Beta pdf
}
return s;
};
NumericVector loglik(std::max(1, p-1), R_NegInf);
int best_q = 0;
double best = R_NegInf;
// Require both segments non-empty: q in [0, p-2]
for(int q=0; q < p-1; q++){
double l1 = seg_loglik(0, q+1);
double l2 = seg_loglik(q+1, p);
double s = l1 + l2;
loglik[q] = s;
if(s > best){ best = s; best_q = q; }
}
return best_q;
}
')
s = sample(1:100, 50, replace = T) |> sort(decreasing = T)
s
getR(s)
betaElbow(s)
quantile(1:354, 0.95)
0.95 * 354
quantile(rnorm(100), 0.95)
x = rnorm(100)
quantile(x, 0.95)
0.95 * x
setwd("~/Library/CloudStorage/OneDrive-Personal/PhD/Exclusion Automatic Threshold Selection/Automatic Threshold Selection")
# Author: Martin Huang (martin.huang@sydney.edu.au)                 #
#         School of Mathematics & Statistics, University of Sydney  #
#         AUSTRALIA                                                 #
#                                                                   #
# The following script provides artificial simulations with         #
# multivariate normal design                                        #
#                                                                   #
# Note: This should take more than 24 hours without parallelisation.#
#       I have provided the Rdata file for my simulations.          #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
source("Functions.R")
# Setting 3: snr = 2
set.seed(1)
n = 200; p = 200; active = 20; repeats = 1000;  snr = 2
true = c(rep(1, active), rep(0,p - active))
S3.2hard = pbreplicate(repeats, simulationATS(X = d$X, beta = d$beta, true = true, p = p, snr = snr))
# Setting 3: snr = 2
set.seed(1)
n = 200; p = 200; active = 20; repeats = 1000;  snr = 2
true = c(rep(1, active), rep(0,p - active))
S3.2hard = pbreplicate(repeats, simulationATS(X = d$X, beta = d$beta, true = true, p = p, snr = snr))
set.seed(1)
n = 20; p = 1000; active = 2; repeats = 1000; snr = 0.5
d = gendata(n = n, p = p, active = active)
true = c(rep(1, active), rep(0,p-active))
d$beta
# Setting 2: snr = 0.5
set.seed(1)
n = 100; p = 500; active = 10; repeats = 1000; snr = 0.5
true = c(rep(1, active), rep(0,p - active ))
d = gendata(n = n, p = p, active = active)
d$beta
set.seed(1)
n = 200; p = 200; active = 20; repeats = 1000;   snr = 0.5
true = c(rep(1, active), rep(0,p - active ))
d = gendata(n = n, p = p, active = active)
d$true
d$beta
# Setting 4: snr = 0.5
set.seed(1)
n = 500; p = 100; active = 20; repeats = 1000; snr = 0.5
true = c(rep(1, active), rep(0,p - active ))
d = gendata(n = n, p = p, active = active)
d$beta
# Setting 2: snr = 0.5
set.seed(1)
n = 100; p = 500; active = 10; repeats = 1000; snr = 0.5
true = c(rep(1, active), rep(0,p - active ))
d = gendata(n = n, p = p, active = active, distribution = "uniform")
d$beta
d$beta[d$beta != 0]
# Setting 2: snr = 0.5
set.seed(1)
n = 100; p = 500; active = 10; repeats = 1000; snr = 0.5
true = c(rep(1, active), rep(0,p - active ))
d = gendata(n = n, p = p, active = active, distribution = "t")
d$beta[d$beta != 0]
